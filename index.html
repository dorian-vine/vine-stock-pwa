<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Vine Stock</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111111"/>
  <style>
    body{font-family:system-ui;margin:14px;max-width:880px}
    h2{margin:8px 0 6px}
    .muted{color:#666;font-size:13px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    input,button,select{font-size:16px;padding:10px}
    button{cursor:pointer}
    .card{border:1px solid #ddd;border-radius:14px;padding:14px;margin:12px 0}
    .pill{display:inline-block;border:1px solid #ddd;border-radius:999px;padding:4px 10px;font-size:13px;color:#444}
    .grid{display:grid;grid-template-columns:1fr;gap:10px}
    @media(min-width:760px){.grid{grid-template-columns:1fr 1fr}}
    .prod{display:flex;gap:10px;align-items:flex-start}
    .prod img{width:64px;height:64px;object-fit:cover;border-radius:10px;background:#f4f4f4}
    .prod h4{margin:0 0 4px;font-size:15px}
    .prod .meta{font-size:13px;color:#555}
    .list{max-height:420px;overflow:auto;border:1px solid #eee;border-radius:12px}
    .item{padding:10px;border-bottom:1px solid #eee}
    .item:last-child{border-bottom:none}
    .ok{color:#0a7}
    .warn{color:#b60}
    .err{color:#c00}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid #eee;padding:8px;font-size:13px;text-align:left}
    .twoCol{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:760px){.twoCol{grid-template-columns:1fr 1fr}}
    .btnPrimary{background:#111;color:#fff;border:none;border-radius:12px}
    .btnGhost{background:#fff;border:1px solid #ddd;border-radius:12px}
    .btnDanger{background:#fff;border:1px solid #f2c; border-radius:12px}
    .small{font-size:13px;padding:8px 10px}
    .hidden{display:none}
  </style>
</head>
<body>

<h2>üì¶ Vine Stock (FNSKU ‚Üí ASIN)</h2>
<div class="row">
  <span class="pill" id="netPill">R√©seau: ?</span>
  <span class="pill" id="cachePill">Base: ?</span>
  <span class="pill" id="mapPill">Mapping: ?</span>
</div>
<div class="muted" style="margin-top:6px">
  Scan via üì∑ cam√©ra (bouton Scanner) ou via Binary Eye ‚Üí colle le FNSKU ici. Si inconnu, recherche + double confirmation. Sync auto quand le r√©seau revient.
</div>

<div class="card">
  <h3 style="margin:0 0 10px">1) Scanner / coller le FNSKU</h3>
  <div class="row">
    <input id="fnsku" placeholder="FNSKU (ex: X000QEDMAD)" style="flex:1;min-width:260px" />
    <button class="btnGhost" id="btnScanCam">üì∑ Scanner</button>
    <button class="btnGhost" id="btnClear">Effacer</button>
  </div>
  <div class="row" style="margin-top:10px">
    <button class="btnPrimary" id="btnLookup">Chercher</button>
    <button class="btnGhost" id="btnSettings">‚öôÔ∏è R√©glages</button>
    <span class="muted" id="status">Pr√™t.</span>
  </div>
</div>

<!-- CAMERA SCAN OVERLAY (Android Chrome) -->
<div id="scanOverlay" style="display:none; position:fixed; inset:0; background:#000; z-index:9999;">
  <video id="scanVideo" autoplay playsinline style="width:100%; height:100%; object-fit:cover;"></video>
  <!-- Cadre visuel -->
  <div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;">
    <div style="width:min(80vw,420px); height:180px; border:2px solid rgba(255,255,255,.9); border-radius:16px;"></div>
  </div>
  <!-- Barre top -->
  <div style="position:absolute; top:0; left:0; right:0; padding:12px; display:flex; gap:10px; align-items:center;">
    <button id="btnStopScan" class="btn" style="background:#fff; color:#000; border:none; border-radius:12px; padding:10px 12px; font-size:16px;">‚úï Fermer</button>
    <button id="btnFlash" class="btn hidden" style="background:#fff; color:#000; border:none; border-radius:12px; padding:10px 12px; font-size:16px;">üî¶ Flash</button>
    <div id="scanMsg" style="color:#fff; font-weight:600;"></div>
  </div>
</div>

<!-- PRODUIT CONNU -->
<div class="card hidden" id="knownBox">
  <h3 style="margin:0 0 10px">Produit trouv√© (FNSKU connu)</h3>
  <div class="prod" id="knownProd"></div>
  <hr style="border:none;border-top:1px solid #eee;margin:12px 0">
  <div class="row">
    <input id="caisseKnown" placeholder="Caisse (ex: A3)" />
    <select id="actionKnown">
      <option value="ADD">ADD (ranger)</option>
      <option value="MOVE">MOVE</option>
      <option value="REMOVE">REMOVE</option>
      <option value="SOLD">SOLD</option>
    </select>
    <button class="btnPrimary" id="btnSaveKnown">‚úÖ Enregistrer</button>
  </div>
  <div class="muted">Caisse propos√©e = derni√®re caisse utilis√©e (globale).</div>
</div>

<!-- FNSKU INCONNU : RECHERCHE -->
<div class="card hidden" id="searchBox">
  <h3 style="margin:0 0 10px">FNSKU inconnu ‚Üí choisir le produit</h3>

  <div class="row">
    <input id="q" placeholder="Recherche (marque / mot / ASIN B0‚Ä¶)" style="flex:1;min-width:260px" />
    <button class="btnGhost" id="btnSearch">Rechercher</button>
  </div>
  <div class="row" style="margin-top:8px">
    <label class="muted" for="accountFilter" style="min-width:120px">Filtre compte</label>
    <select id="accountFilter" style="flex:1;min-width:260px">
      <option value="">Tous les comptes</option>
    </select>
  </div>
  <div class="muted" style="margin-top:8px">
    R√©sultats depuis la base produits locale. (Si vide: fais une mise √† jour en ligne dans R√©glages.)
  </div>

  <div class="list" id="results" style="margin-top:10px"></div>
</div>

<!-- CONFIRMATION (Option B) -->
<div class="card hidden" id="confirmBox">
  <h3 style="margin:0 0 10px">2) Double confirmation</h3>

  <div class="twoCol">
    <div class="card" style="margin:0">
      <h4 style="margin:0 0 8px">Produit choisi</h4>
      <div class="prod" id="confirmProd"></div>
      <div class="row" style="margin-top:10px">
        <a id="confirmLink" href="#" target="_blank" class="pill">Ouvrir Amazon</a>
        <span class="pill" id="confirmAsin">ASIN: ?</span>
        <span class="pill" id="confirmPrice">Prix: ?</span>
        <span class="pill" id="confirmCaisses">üß∫ Stock global: ‚Äî</span>
      </div>
    </div>

    <div class="card" style="margin:0">
      <h4 style="margin:0 0 8px">Historique (MASTER)</h4>
      <div class="muted" id="histHint">Si offline, historique = dernier cache.</div>
      <div style="max-height:240px;overflow:auto;border:1px solid #eee;border-radius:12px">
        <table>
          <thead><tr><th>Date</th><th>Email</th></tr></thead>
          <tbody id="histTable"></tbody>
        </table>
      </div>
    </div>
  </div>

  <hr style="border:none;border-top:1px solid #eee;margin:12px 0">

  <div class="row">
    <button class="btnPrimary" id="btnLink">‚úÖ Valider le lien FNSKU ‚Üí ASIN</button>
    <button class="btnGhost" id="btnChange">‚Ü©Ô∏è Changer de produit</button>
    <span class="muted" id="linkStatus"></span>
  </div>
</div>

<!-- APR√àS LIEN : RANGEMENT -->
<div class="card hidden" id="afterLinkBox">
  <h3 style="margin:0 0 10px">3) Ranger / enregistrer</h3>
  <div class="prod" id="afterProd"></div>
  <div class="row" style="margin-top:10px">
    <input id="caisseAfter" placeholder="Caisse (ex: A3)" />
    <select id="actionAfter">
      <option value="ADD">ADD (ranger)</option>
      <option value="MOVE">MOVE</option>
      <option value="REMOVE">REMOVE</option>
      <option value="SOLD">SOLD</option>
    </select>
    <button class="btnPrimary" id="btnSaveAfter">‚úÖ Enregistrer</button>
  </div>
  <div class="muted">Caisse propos√©e = derni√®re caisse utilis√©e (globale).</div>
</div>

<!-- HISTORIQUE LOCAL (actions) -->
<div class="card">
  <h3 style="margin:0 0 10px">üïì Derni√®res actions (local)</h3>
  <div class="row">
    <button class="btnGhost small" id="btnSyncNow">Sync maintenant</button>
    <button class="btnGhost small" id="btnPullNow">Mettre √† jour base + mapping</button>
    <button class="btnGhost small" id="btnRebuildState">Rebuild stock (serveur)</button>

    <span class="muted" id="syncMsg"></span>
  </div>
  <div style="max-height:260px;overflow:auto;border:1px solid #eee;border-radius:12px;margin-top:10px">
    <table>
      <thead><tr><th>Date</th><th>FNSKU</th><th>ASIN</th><th>Caisse</th><th>Action</th><th>Sync</th></tr></thead>
      <tbody id="actionsTable"></tbody>
    </table>
  </div>
</div>

<!-- SETTINGS -->
<div class="card hidden" id="settingsBox">
  <h3 style="margin:0 0 10px">‚öôÔ∏è R√©glages</h3>
  <div class="muted">Colle ici l‚ÄôURL /exec de ton Apps Script + ton SECRET.</div>
  <div class="row" style="margin-top:10px">
    <input id="apiUrl" placeholder="https://script.google.com/macros/s/.../exec" style="flex:1;min-width:280px"/>
    <input id="secret" placeholder="SECRET" style="min-width:180px"/>
  </div>
  <div class="row" style="margin-top:10px">
    <button class="btnPrimary" id="btnSaveSettings">Enregistrer</button>
    <button class="btnGhost" id="btnCloseSettings">Fermer</button>
    <span class="muted" id="settingsStatus"></span>
  </div>

  <hr style="border:none;border-top:1px solid #eee;margin:12px 0">
  <div class="row">
    <button class="btnGhost" id="btnResetCache">R√©initialiser cache local</button>
    <span class="muted">‚ö†Ô∏è Efface base produits, mapping et actions non sync.</span>
  </div>
</div>

<script>
/* PWA cache */
if('serviceWorker' in navigator){ navigator.serviceWorker.register('sw.js'); }

const $ = (id)=>document.getElementById(id);
const netPill=$('netPill'), cachePill=$('cachePill'), mapPill=$('mapPill');

const LS = {
  apiUrl: 'vine_api_url',
  secret: 'vine_secret',
  device: 'vine_device',
  lastCaisse: 'vine_last_caisse',
  lastPull: 'vine_last_pull',
  caisseMap: 'vine_caisse_by_asin',
  caisseCountMap: 'vine_caisse_counts_by_asin',
  actionsCursor: 'vine_actions_cursor',
  stateMap: 'vine_state_by_fnsku',
  fnskuMap: 'vine_fnskuMap',
  lang: 'vine_lang'
};

const deviceId = localStorage.getItem(LS.device) || (()=>{
  const v='phone_'+Math.random().toString(16).slice(2,8);
  localStorage.setItem(LS.device, v);
  return v;
})();

let apiUrl = localStorage.getItem(LS.apiUrl) || '';
let secret = localStorage.getItem(LS.secret) || '';
let lastCaisse = (localStorage.getItem(LS.lastCaisse) || '').toUpperCase();

$('apiUrl').value = apiUrl;
$('secret').value = secret;

const DB_NAME='vine_global', DB_VER=1;
let db;

/* IndexedDB stores:
  - products (key asin) => {asin,title,photo_url,product_url,price,orders_count,history}
  - mapping (key fnsku) => {fnsku,asin,linked_at,device}
  - actions (auto id) => {id,ts,device,fnsku,asin,caisse,action,synced:false}
*/
function openDB(){
  return new Promise((res,rej)=>{
    const r=indexedDB.open(DB_NAME, DB_VER);
    r.onupgradeneeded=()=>{
      const d=r.result;
      if(!d.objectStoreNames.contains('products')) d.createObjectStore('products', {keyPath:'asin'});
      if(!d.objectStoreNames.contains('mapping')) d.createObjectStore('mapping', {keyPath:'fnsku'});
      if(!d.objectStoreNames.contains('actions')) d.createObjectStore('actions', {keyPath:'id'});
    };
    r.onsuccess=()=>res(r.result);
    r.onerror=()=>rej(r.error);
  });
}

function idbPut(store, val){
  return new Promise((res,rej)=>{
    const tx=db.transaction(store,'readwrite');
    tx.objectStore(store).put(val);
    tx.oncomplete=()=>res();
    tx.onerror=()=>rej(tx.error);
  });
}
function idbGet(store, key){
  return new Promise((res,rej)=>{
    const tx=db.transaction(store,'readonly');
    const req=tx.objectStore(store).get(key);
    req.onsuccess=()=>res(req.result||null);
    req.onerror=()=>rej(req.error);
  });
}
function idbGetAll(store){
  return new Promise((res,rej)=>{
    const tx=db.transaction(store,'readonly');
    const req=tx.objectStore(store).getAll();
    req.onsuccess=()=>res(req.result||[]);
    req.onerror=()=>rej(req.error);
  });
}
function idbDelAll(store){
  return new Promise((res,rej)=>{
    const tx=db.transaction(store,'readwrite');
    const req=tx.objectStore(store).clear();
    req.onsuccess=()=>res();
    req.onerror=()=>rej(req.error);
  });
}

async function pullAllActionsFromServer(){
  if(!online()) return 0;
  if(!apiUrl || !secret) return 0;
  let cursor = 0;
  let total = 0;
  while(true){
    const r = await apiGet(`op=pull_actions&cursor=${cursor}&limit=2000`);
    if(!r.ok) throw new Error(r.error||'pull_actions failed');
    const actions = r.actions||[];
    for(const a of actions){
      // Store in IDB; mark as synced
      await idbPut('actions', { ...a, synced:true });
    }
    total += actions.length;
    if(r.next_cursor===null || r.next_cursor===undefined) break;
    cursor = r.next_cursor;
    if(actions.length===0) break;
  }
  return total;
}


// --- Anti-duplicate save (multi-device safe) ---
let lastSaveKey = '';
let lastSaveAt = 0;

// Fast hash (FNV-1a 32-bit) to generate stable IDs without crypto APIs
function fnv1a32(str){
  let h = 0x811c9dc5;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = (h + ((h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24))) >>> 0;
  }
  return h >>> 0;
}

function makeStableActionId(fnsku, asin, caisse, action){
  const now = Date.now();
  const bucket = Math.floor(now / 3000); // 3s bucket (prevents double clicks / retries)
  const key = [deviceId, fnsku, asin, caisse, action, bucket].join('|');
  return deviceId + '_' + fnv1a32(key).toString(16);
}

async function rebuildCaisseStateFromActions(){
  const acts = await idbGetAll('actions');
  acts.sort((a,b)=>{
    const ta = Date.parse(a.ts||'') || 0;
    const tb = Date.parse(b.ts||'') || 0;
    if(ta!==tb) return ta-tb;
    return String(a.id||'').localeCompare(String(b.id||''));
  });
  const caisseByAsin = {};
  const caisseCounts = {};
  for(const a of acts){
    const asin = (a.asin||'').toUpperCase().trim();
    if(!asin) continue;
    const action = (a.action||'').toUpperCase().trim();
    const caisse = (a.caisse||'').toUpperCase().trim();

    if(action==='SOLD' || action==='REMOVE'){
      caisseByAsin[asin] = '';
    } else if(action==='ADD' || action==='MOVE'){
      caisseByAsin[asin] = caisse;
    }

    // Optional counts by (asin,caisse) for UI badges
    const key = asin+'||'+(caisse||'');
    const delta = (action==='SOLD'||action==='REMOVE') ? -1 : 1;
    caisseCounts[key] = (caisseCounts[key]||0) + delta;
  }
  localStorage.setItem(LS.caisseMap, JSON.stringify(caisseByAsin));
  localStorage.setItem(LS.caisseCountMap, JSON.stringify(caisseCounts));
}


function loadStateMap(){
  try{ return JSON.parse(localStorage.getItem(LS.stateMap)||'{}')||{}; }catch(e){ return {}; }
}
function saveStateMap(m){
  localStorage.setItem(LS.stateMap, JSON.stringify(m||{}));
}
function stateBadgesForFnsku(fnsku){
  const sm = loadStateMap();
  const o = sm[(fnsku||'').toUpperCase().trim()];
  if(!o || !o.caisses) return '‚Äî';
  const parts = [];
  for(const [c, q] of Object.entries(o.caisses)){
    const n = Number(q)||0;
    if(n>0) parts.push(`${c}√ó${n}`);
  }
  return parts.length ? parts.sort().join('  ') : '‚Äî';
}
function applyQtyLocal(fnsku, asin, caisse, action){
  fnsku = (fnsku||'').toUpperCase().trim();
  asin = (asin||'').toUpperCase().trim();
  caisse = (caisse||'').toUpperCase().trim();
  if(!fnsku || !caisse) return;
  const sm = loadStateMap();
  if(!sm[fnsku]) sm[fnsku] = { asin: asin || '', caisses: {} };
  if(asin) sm[fnsku].asin = asin;
  if(!sm[fnsku].caisses) sm[fnsku].caisses = {};
  const cur = Number(sm[fnsku].caisses[caisse]||0)||0;
  let delta = 0;
  const a = (action||'').toUpperCase().trim();
  if(a==='ADD') delta = 1;
  else if(a==='REMOVE' || a==='SOLD') delta = -1;
  const nxt = Math.max(0, cur + delta);
  sm[fnsku].caisses[caisse] = nxt;
  saveStateMap(sm);
}


/* Helpers */
function setStatus(msg, cls=''){
  $('status').textContent = msg;
  $('status').className = 'muted ' + cls;
}
function online(){ return navigator.onLine; }

function normFnsku(v){
  return (v||'').toString().trim().toUpperCase();
}

// Recherche non sensible aux accents (√©=e, √†=a, √ß=c)
function foldText(s){
  return (s||'').toString()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g,'')
    .toUpperCase();
}

// Caisses par ASIN (plusieurs caisses possibles)
function getCaisseMap(){
  try{ return JSON.parse(localStorage.getItem(LS.caisseMap) || '{}') || {}; }
  catch(e){ return {}; }
}
function getCaissesForAsin(asin){
  // Legacy: previously stored per ASIN. Now we use stateMap (per FNSKU) and aggregate by ASIN.
  asin = (asin||'').toUpperCase().trim();
  const sm = loadStateMap();
  const agg = {};
  for(const [fn, obj] of Object.entries(sm)){
    if(!obj) continue;
    const a = (obj.asin||'').toUpperCase().trim();
    if(asin && a!==asin) continue;
    const ca = obj.caisses||{};
    for(const [c,q] of Object.entries(ca)){
      const n = Number(q)||0;
      if(n<=0) continue;
      agg[c] = (agg[c]||0) + n;
    }
  }
  return Object.entries(agg).sort((x,y)=>x[0].localeCompare(y[0])).map(([c,n])=>`${c}√ó${n}`);
}
function setCaissesForAsin(asin, caisses){
  asin = normAsin(asin);
  const m = getCaisseMap();
  const clean = Array.from(new Set(
    (caisses||[])
      .map(x=>String(x||'').trim().toUpperCase())
      .filter(Boolean)
  ));
  if(clean.length) m[asin] = clean; else delete m[asin];
  localStorage.setItem(LS.caisseMap, JSON.stringify(m));
}

// ===== Caisses avec quantit√©s (compteurs) ‚Äî source: STOCK_ACTIONS (local) =====
function getCaisseCountMap(){
  try{ return JSON.parse(localStorage.getItem(LS.caisseCountMap) || '{}') || {}; }
  catch(e){ return {}; }
}
function getCaisseCountsForAsin(asin){
  asin = normAsin(asin);
  const m = getCaisseCountMap();
  const v = m[asin];
  return (v && typeof v === 'object' && !Array.isArray(v)) ? v : {};
}
function setCaisseCountsForAsin(asin, countsObj){
  asin = normAsin(asin);
  const m = getCaisseCountMap();
  const clean = {};
  for(const [k,v] of Object.entries(countsObj||{})){
    const c = String(k||'').trim().toUpperCase();
    const n = Number(v||0);
    if(c && n>0) clean[c]=n;
  }
  if(Object.keys(clean).length) m[asin] = clean; else delete m[asin];
  localStorage.setItem(LS.caisseCountMap, JSON.stringify(m));
}
function applyCaisseCountAction(asin, caisse, action){
  asin = normAsin(asin);
  caisse = (caisse||'').toString().trim().toUpperCase();
  action = (action||'').toString().trim().toUpperCase();
  if(!asin || !/^[A-Z0-9]{10}$/.test(asin) || !caisse) return;

  const cur = getCaisseCountsForAsin(asin);
  const now = Number(cur[caisse] || 0);

  if(action === 'REMOVE' || action === 'SOLD'){
    const n = Math.max(0, now - 1);
    if(n===0) delete cur[caisse]; else cur[caisse]=n;
  }else{
    // ADD / MOVE / autres
    cur[caisse] = now + 1;
  }
  setCaisseCountsForAsin(asin, cur);
}
function fmtCaisseCountsForAsin(asin){
  // ‚úÖ Multi-caisses + quantit√©s: aggregate from stateMap (per FNSKU) by ASIN
  asin = (asin||'').toUpperCase().trim();
  const sm = loadStateMap();
  const agg = {};
  for(const [fn, obj] of Object.entries(sm)){
    if(!obj) continue;
    const a = (obj.asin||'').toUpperCase().trim();
    if(asin && a!==asin) continue;
    const ca = obj.caisses||{};
    for(const [c,q] of Object.entries(ca)){
      const n = Number(q)||0;
      if(n<=0) continue;
      agg[c] = (agg[c]||0) + n;
    }
  }
  const parts = Object.entries(agg)
    .sort((x,y)=>x[0].localeCompare(y[0]))
    .map(([c,n])=>`${c}√ó${n}`);
  if(!parts.length) return '';
  return ' ¬∑ üß∫ ' + parts.join(' ¬∑ ');
}


// ===== Langue (FR/‰∏≠Êñá) + Titres chinois (optionnel) =====
function getLang(){
  return localStorage.getItem(LS.lang) || 'fr';
}
function setLang(v){
  localStorage.setItem(LS.lang, v || 'fr');
}
function titleFor(p){
  const lang = getLang();
  if(lang==='zh' && p && p.title_zh) return String(p.title_zh);
  return String((p && p.title) || '');
}

// ===== FNSKU(s) par ASIN (rebuild depuis le mapping) =====
function getFnskuMap(){
  try{ return JSON.parse(localStorage.getItem(LS.fnskuMap) || '{}') || {}; }
  catch(e){ return {}; }
}
function setFnskuMap(map){
  localStorage.setItem(LS.fnskuMap, JSON.stringify(map || {}));
}
function getFnskusForAsin(asin){
  asin = normAsin(asin);
  if(!asin) return [];
  const map = getFnskuMap();
  const arr = map[asin] || [];
  return Array.isArray(arr) ? arr : [];
}
function rebuildFnskuMapFromMapping(list){
  const map = {};
  if(Array.isArray(list)){
    for(const it of list){
      if(!it) continue;
      const asin = normAsin(it.asin);
      const fnsku = normFnsku(it.fnsku);
      if(!asin || !fnsku) continue;
      (map[asin] ||= []);
      if(!map[asin].includes(fnsku)) map[asin].push(fnsku);
    }
  }
  setFnskuMap(map);
}
function addFnskuLinkLocal(fnsku, asin){
  fnsku = normFnsku(fnsku);
  asin = normAsin(asin);
  if(!fnsku || !asin) return;
  const map = getFnskuMap();
  const arr = Array.isArray(map[asin]) ? map[asin] : [];
  if(!arr.includes(fnsku)) arr.push(fnsku);
  map[asin] = arr;
  setFnskuMap(map);
}
function fmtFnskuBadgeForAsin(asin){
  const list = getFnskusForAsin(asin);
  if(!list.length) return '';
  const first = list[0];
  const more = list.length>1 ? ` (+${list.length-1})` : '';
  return ` ¬∑ üè∑Ô∏è <b>${escapeHtml(first)}</b>${more}`;
}

// Si l'utilisateur installe une nouvelle version (avec quantites) alors qu'il a deja
// un historique d'actions en local (ou un cursor de sync), la map des caisses/quantites
// peut etre vide. On peut la reconstruire a partir des actions locales.
async function rebuildCaisseMapsFromLocalActions_(){
  const acts = await idbGetAll('actions');
  if(!acts || !acts.length) return {rebuilt:false, total:0};
  // reset maps
  localStorage.setItem(LS.caisseMap, JSON.stringify({}));
  localStorage.setItem(LS.caisseCountMap, JSON.stringify({}));
  // applique dans l'ordre chrono (optionnel)
  acts
    .slice()
    .sort((a,b)=> String(a.ts||'').localeCompare(String(b.ts||'')))
    .forEach(a=>{
      // apply helpers attend (asin, caisse, action)
      applyCaisseAction(a.asin, a.caisse, a.action);
      applyCaisseCountAction(a.asin, a.caisse, a.action);
    });
  return {rebuilt:true, total:acts.length};
}

async function ensureCaisseMapsReady_(){
  try{
    const raw = localStorage.getItem(LS.caisseCountMap);
    const cur = (localStorage.getItem(LS.actionsCursor)||'').trim();
    let obj = {};
    try{ obj = raw ? JSON.parse(raw) : {}; }catch(_){ obj = {}; }
    const empty = !raw || !obj || Object.keys(obj).length===0;
    // si cursor existe ou actions locales existent, on reconstruit une fois
    if(empty){
      const r = await rebuildCaisseMapsFromLocalActions_();
      if(r && r.rebuilt){
        // petit indicateur non bloquant
        try{ $('syncMsg').textContent = `üß∫ Caisses reconstruites (${r.total} actions locales).`; }catch(_){ }
      }else if(cur){
        // si on a un cursor mais aucune action locale, on force un rebuild au prochain pull
        // (cursor=1 => pull depuis le debut)
        localStorage.setItem(LS.actionsCursor, '1');
      }
    }
  }catch(_){ /* no-op */ }
}

function applyCaisseAction(asin, caisse, action){
  asin = normAsin(asin);
  caisse = (caisse||'').toString().trim().toUpperCase();
  action = (action||'').toString().trim().toUpperCase();
  if(!asin || !/^[A-Z0-9]{10}$/.test(asin) || !caisse) return;

  const cur = getCaissesForAsin(asin);
  if(action === 'REMOVE' || action === 'SOLD'){
    setCaissesForAsin(asin, cur.filter(c=>c!==caisse));
  }else{
    // ADD / MOVE / autres ‚Üí on ajoute la caisse (multi-caisses)
    cur.push(caisse);
    setCaissesForAsin(asin, cur);
  }
}
function normAsin(v){
  v=(v||'').toString().trim().toUpperCase();
  const m=v.match(/\/dp\/([A-Z0-9]{10})/i);
  if(m) return m[1].toUpperCase();
  const m2=v.match(/ASIN[:\s]*([A-Z0-9]{10})/i);
  if(m2) return m2[1].toUpperCase();
  return v;
}

function fmtDate(ts){
  if(!ts) return '';
  return ts.toString().slice(0,16).replace('T',' ');
}

/* Dates + tri (Option A: 1 date par compte = 1√®re commande) */
function jjmm(dateStr){
  if(!dateStr) return '';
  // Supporte "YYYY-MM-DD HH:MM:SS" et ISO
  const s = String(dateStr).trim().replace(' ', 'T');
  const d = new Date(s);
  if(isNaN(d)) return '';
  const dd = String(d.getDate()).padStart(2,'0');
  const mm = String(d.getMonth()+1).padStart(2,'0');
  return `${dd}/${mm}`;
}

function aliasFromEmail(email){
  const e = (email||'').toString().trim().toLowerCase();
  if(!e) return '';
  const local = (e.split('@')[0] || e);
  const first = local.replace(/[^a-z0-9]+/gi,' ').trim().split(' ')[0] || local;
  return first.charAt(0).toUpperCase() + first.slice(1);
}

function accountsWithFirstOrderDate(history){
  const minTsByEmail = new Map();
  (history||[]).forEach(h=>{
    const email = (h.email||'').toString().trim().toLowerCase();
    if(!email) return;
    const ts = Date.parse(String(h.order_date||'').trim().replace(' ', 'T'));
    if(isNaN(ts)) return;
    const prev = minTsByEmail.get(email);
    if(prev === undefined || ts < prev) minTsByEmail.set(email, ts);
  });

  return Array.from(minTsByEmail.entries())
    .sort((a,b)=>a[1]-b[1]) // plus ancienne d'abord
    .map(([email, ts])=>{
      const name = aliasFromEmail(email);
      const d = jjmm(new Date(ts).toISOString());
      return d ? `${name} (${d})` : name;
    });
}

// Tri par date de commande la plus r√©cente (dernier event de history)
function getLastOrderTimestamp(product){
  const hist = Array.isArray(product?.history) ? product.history : [];
  let maxTs = 0;
  for(const h of hist){
    const ts = Date.parse(String(h.order_date||'').trim().replace(' ', 'T'));
    if(!isNaN(ts) && ts > maxTs) maxTs = ts;
  }
  return maxTs;
}

// Derni√®re date (timestamp) pour un email sp√©cifique (pour tri quand filtre compte actif)
function getLastOrderTimestampForEmail(product, emailLower){
  const hist = Array.isArray(product?.history) ? product.history : [];
  let maxTs = 0;
  for(const h of hist){
    const em = (h.email||'').toString().trim().toLowerCase();
    if(!em || em !== emailLower) continue;
    const ts = Date.parse(String(h.order_date||'').trim().replace(' ', 'T'));
    if(!isNaN(ts) && ts > maxTs) maxTs = ts;
  }
  return maxTs;
}

// Construit la liste des emails de comptes pr√©sents dans la base (unique)
function collectAccountEmails(products){
  const set = new Set();
  for(const p of (products||[])){
    const hist = Array.isArray(p?.history) ? p.history : [];
    for(const h of hist){
      const em = (h.email||'').toString().trim().toLowerCase();
      if(em) set.add(em);
    }
  }
  return Array.from(set).sort();
}


function prodHTML(p, opts){
  opts = opts || {};
  const img = p.photo_url
    ? `<img src="${p.photo_url}" alt="">`
    : `<div class="ph">üì¶</div>`;

  const price = p.price ? ` ¬∑ <b>${p.price}</b>` : '';

  // Comptes + date JJ/MM
  const acc = accountsWithFirstOrderDate(p.history || []);
  const cnt = acc.length
    ? ` ¬∑ üë§ ${acc.length} comptes: ${acc.join(' ¬∑ ')}`
    : '';

  const ccBadge = fmtCaisseCountsForAsin(p.asin);
  const fnskuBadge = fmtFnskuBadgeForAsin(p.asin);

  // opts.fnsku peut √™tre un string... ou un <input> (bug observ√©: "[object HTMLInputElement]")
  let rawFnsku = '';
  if (opts && opts.fnsku != null) {
    if (typeof opts.fnsku === 'string') rawFnsku = opts.fnsku;
    else if (typeof opts.fnsku === 'object' && 'value' in opts.fnsku) rawFnsku = String(opts.fnsku.value || '');
    else rawFnsku = String(opts.fnsku);
  }
  rawFnsku = normFnsku(rawFnsku);
  const scannedFnsku = rawFnsku ? ` ¬∑ FNSKU: <b>${escapeHtml(rawFnsku)}</b>` : '';

  return `
    ${img}
    <div>
      <h4>${escapeHtml(titleFor(p))}</h4>
      <div class="meta">
        ASIN: <b>${p.asin}</b>${price}${cnt}${ccBadge}${fnskuBadge}${scannedFnsku}
      </div>
      <div class="meta">
        ${p.product_url ? `<a href="${p.product_url}" target="_blank">Lien produit</a>` : ''}
      </div>
    </div>
  `;
}

function escapeHtml(s){
  return (s||'').toString().replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[m]));
}

async function refreshPills(){
  netPill.textContent = 'R√©seau: ' + (online() ? 'ONLINE' : 'OFFLINE');
  netPill.className = 'pill ' + (online() ? 'ok' : 'warn');

  const prodCount = (await idbGetAll('products')).length;
  cachePill.textContent = 'Base: ' + prodCount + ' ASIN';
  cachePill.className = 'pill ' + (prodCount>0 ? 'ok' : 'warn');

  const mapCount = (await idbGetAll('mapping')).length;
  mapPill.textContent = 'Mapping: ' + mapCount;
  mapPill.className = 'pill ' + (mapCount>0 ? 'ok' : 'warn');
}

async function renderActions(){
  const actions = (await idbGetAll('actions'))
    .sort((a,b)=> (b.ts||'').localeCompare(a.ts||''))
    .slice(0,60);
  $('actionsTable').innerHTML = actions.map(a=>`
    <tr>
      <td>${fmtDate(a.ts)}</td>
      <td>${escapeHtml(a.fnsku||'')}</td>
      <td>${escapeHtml(a.asin||'')}</td>
      <td>${escapeHtml(a.caisse||'')}</td>
      <td>${escapeHtml(a.action||'')}</td>
      <td>${a.synced ? '‚úî' : '‚Ä¶'}</td>
    </tr>
  `).join('');
}


function resetToScan(){
  try{
    selectedProduct = null;
    currentFnsku = '';
    showOnly('scanBox');
    setStatus('Pr√™t.', '');
    $('fnsku').value = '';
    $('fnsku').focus();
    if($('afterProd')) $('afterProd').innerHTML = '';
    if($('linkStatus')) { $('linkStatus').textContent=''; $('linkStatus').className='muted'; }
  }catch(e){}
}

function showOnly(boxId){
  const ids=['knownBox','searchBox','confirmBox','afterLinkBox','settingsBox'];
  ids.forEach(id=>$(id).classList.add('hidden'));
  if(boxId) $(boxId).classList.remove('hidden');
}

function proposeCaisse(){
  const c = (localStorage.getItem(LS.lastCaisse) || '').toUpperCase();
  $('caisseKnown').value = c;
  $('caisseAfter').value = c;
}

/* API */
function fetchWithTimeout(url, options = {}, ms = 15000){
  const ctrl = new AbortController();
  const id = setTimeout(()=>ctrl.abort(), ms);
  return fetch(url, {...options, signal: ctrl.signal}).finally(()=>clearTimeout(id));
}

async function apiGet(params = {}) {
  if (!apiUrl || !secret) throw new Error("R√©glages manquants (API URL / SECRET).");

  const u = new URL(apiUrl);
  u.searchParams.set("secret", secret);

  for (const [k, v] of Object.entries(params || {})) {
    u.searchParams.set(k, String(v ?? ""));
  }

  // anti-cache
  u.searchParams.set("_", String(Date.now()));

  const r = await fetchWithTimeout(u.toString(), { method: "GET" }, 15000);
  if (!r.ok) throw new Error("HTTP_" + r.status);
  return await r.json();
}

async function apiPost(body = {}) {
  if (!apiUrl || !secret) throw new Error("R√©glages manquants (API URL / SECRET).");

  // IMPORTANT : Apps Script aime bien text/plain (√©vite CORS/OPTIONS selon les cas)
  const payload = JSON.stringify({ secret, ...(body || {}) });

  const r = await fetchWithTimeout(
    apiUrl,
    {
      method: "POST",
      headers: { "Content-Type": "text/plain;charset=utf-8" },
      body: payload,
    },
    15000
  );

  if (!r.ok) throw new Error("HTTP_" + r.status);
  return await r.json();
}


/* Pull master + mapping */
async function pullAll(){
  if(!online()) return;
  if(!apiUrl || !secret) return;

  $('syncMsg').textContent = '‚è≥ Mise √† jour base + mapping...';
  try{
    const [m1, m2] = await Promise.all([
      apiGet({op:'pull_master_full'}),
      apiGet({op:'pull_mapping'})
    ]);

    if(m1.ok && Array.isArray(m1.products)){
      for(const p of m1.products){
        // Normalise
        p.asin = normAsin(p.asin);
        p.history = Array.isArray(p.history) ? p.history : [];
        await idbPut('products', p);
      }
      localStorage.setItem(LS.lastPull, new Date().toISOString());
    }

    if(m2.ok && Array.isArray(m2.mapping)){
      // Rebuild FNSKU map (ASIN -> [FNSKU])
      rebuildFnskuMapFromMapping(m2.mapping);

      for(const it of m2.mapping){
        it.fnsku = normFnsku(it.fnsku);
        it.asin = normAsin(it.asin);
        await idbPut('mapping', it);
      }
    }

    // IMPORTANT : les "caisses" sont multi-appareils (stock global) et synchronis√©es via STOCK_ACTIONS (voir autoSync)
    // donc on doit aussi tirer les actions du Google Sheet pour que les caisses soient identiques sur tous les telephones.
    // (necessite l'op Apps Script: pull_actions)
    await pullStockActions({silent:true});

    // Apres pull des actions, on regenere la vue.
    await refreshPills();
    // ‚úÖ Retour automatique au scan
  resetToScan();
await renderActions();

    $('syncMsg').textContent = '‚úÖ Base + mapping √† jour';
  }catch(e){
    $('syncMsg').textContent = '‚ùå Pull impossible ('+ (e.message||e) +')';
  }
  await refreshPills();
}

/* Push actions */
async function pushActions(){
  if(!online()) return;
  if(!apiUrl || !secret) return;

  const all = await idbGetAll('actions');
  const pending = all.filter(a=>!a.synced);

  if(!pending.length) return;

  $('syncMsg').textContent = '‚è≥ Sync actions ('+pending.length+')...';

  try{
    const resp = await apiPost({op:'push_actions', actions: pending});
    if(resp.ok){
      // mark synced (we re-put by id)
      const appended = resp.appended || 0;
      const skipped = resp.skipped || 0;

      // safest: mark everything we attempted as synced (ids are unique, server dedup)
      for(const a of pending){
        a.synced = true;
        await idbPut('actions', a);
      }

      $('syncMsg').textContent = `‚úÖ Sync OK (app:${appended}, skip:${skipped})`;
      await renderActions();
    }else{
      $('syncMsg').textContent = '‚ùå Sync refus√©e: '+(resp.error||'');
    }
  }catch(e){
    $('syncMsg').textContent = '‚ùå Sync impossible (r√©seau)';
  }
}


/* Pull STOCK_ACTIONS (cursor) + reconstruire les caisses (global multi-t√©l√©phones) */
async function pullStockActions(){
  // ‚úÖ Full replay sync: every device rebuilds caisse state from the same server log.
  if(!online()) return {pulled:0};
  if(!apiUrl || !secret) return {pulled:0};

  const pulled = await pullAllActionsFromServer();
  await rebuildCaisseStateFromActions();

  // cursor not used anymore (avoids desync)
  localStorage.removeItem(LS.actionsCursor);

  return {pulled};
}


async function pullState(){
  if(!online()) return {pulled:0};
  if(!apiUrl || !secret) return {pulled:0};

  const r = await apiGet('op=pull_state');
  if(!r.ok) throw new Error(r.error||'pull_state failed');
  const arr = r.state || [];

  const sm = {};
  for(const it of arr){
    const fnsku = (it.fnsku||'').toUpperCase().trim();
    const caisse = (it.caisse||'').toUpperCase().trim();
    if(!fnsku || !caisse) continue;
    if(!sm[fnsku]) sm[fnsku] = { asin: (it.asin||'').toUpperCase().trim(), caisses:{} };
    if(it.asin) sm[fnsku].asin = (it.asin||'').toUpperCase().trim();
    sm[fnsku].caisses[caisse] = Number(it.qty||0)||0;
  }
  saveStateMap(sm);
  return {pulled: arr.length};
}



/* Auto sync: when online => push then pull */
let syncLock=false;
async function autoSync(){
  if(syncLock) return;
  if(!online()) return;
  if(!apiUrl || !secret) return;
  syncLock=true;
  try{
    await pushActions();
    // Phase 2 (recommand√©e) : on pull STOCK_ACTIONS et on reconstruit les caisses globales
    try{
      const r = await pullStockActions();
      if(r && r.pulled){
        $('syncMsg').textContent = `‚úÖ Stock actions mises √† jour (+${r.pulled})`;
      }
    }catch(e){
      // on n'emp√™che pas la suite (base + mapping)
      $('syncMsg').textContent = '‚ö†Ô∏è Stock actions: '+(e.message||e);
    }
    await pullAll();
  }finally{
    syncLock=false;
  }
}

/* Lookup flow */
let currentFnsku='', selectedProduct=null;

async function lookupFnsku(){

  const rawIn = ($('fnsku').value||'').trim();

  // ‚úÖ Mode ASIN supprim√© : on ne bascule PLUS jamais en "Code reconnu".
  // Si l'utilisateur colle une URL Amazon ou un ASIN, on tente juste de retrouver
  // un FNSKU via le mapping (si unique), puis on continue en mode FNSKU.
  let maybeAsin = '';
  try{
    const m1 = rawIn.match(/\/dp\/([A-Z0-9]{10})/i);
    const m2 = rawIn.match(/\bASIN[:\s]*([A-Z0-9]{10})\b/i);
    const m3 = rawIn.match(/\b([A-Z0-9]{10})\b/i);
    maybeAsin = (m1 && m1[1]) || (m2 && m2[1]) || (m3 && m3[1]) || '';
    maybeAsin = (maybeAsin||'').toUpperCase().trim();
  }catch(_){}

  // Si √ßa ressemble √† un ASIN (10 chars) MAIS que l'entr√©e n'est pas un FNSKU (souvent X00...),
  // on essaye de trouver un FNSKU dans le mapping et on remplace le champ automatiquement.
  if(maybeAsin && /^[A-Z0-9]{10}$/.test(maybeAsin) && !/^X[0-9A-Z]{9}$/.test(maybeAsin)){
    try{
      const mpAll = await idbGetAll('mapping');
      const hits = mpAll.filter(x => x && normAsin(x.asin) === maybeAsin && x.fnsku);
      if(hits.length === 1){
        $('fnsku').value = normFnsku(hits[0].fnsku);
      }
    }catch(_){}
  }

  // Mode normal : FNSKU

  currentFnsku = normFnsku(rawIn);
  $('fnsku').value = currentFnsku;
  if(!currentFnsku){ setStatus('FNSKU vide', 'warn'); return; }

  showOnly(null);
  $('knownBox').classList.add('hidden');
  $('searchBox').classList.add('hidden');
  $('confirmBox').classList.add('hidden');
  $('afterLinkBox').classList.add('hidden');

  setStatus('Recherche mapping...', '');
  const mapped = await idbGet('mapping', currentFnsku);

  if(mapped && mapped.asin){
    const asin = normAsin(mapped.asin);
    const p = await idbGet('products', asin);
    if(p){
      $('knownProd').innerHTML = prodHTML(p, {fnsku: currentFnsku});
    }else{
      $('knownProd').innerHTML = `<div class="muted warn">Produit non trouv√© dans la base locale (ASIN: ${asin}). Fais une mise √† jour en ligne.</div>`;
    }
    proposeCaisse();
    showOnly('knownBox');
    setStatus('FNSKU connu.', 'ok');
    return;
  }

  // Unknown => search
  showOnly('searchBox');
  setStatus('FNSKU inconnu ‚Üí recherche produit.', 'warn');
  $('q').value = '';
  $('results').innerHTML = '';
  $('q').focus();
}

/* Search products */
async function doSearch(){
  const qRaw = ($('q').value||'').trim();
  const q = qRaw.toUpperCase();
  const qFold = foldText(qRaw);
  const all = await idbGetAll('products');

  // Remplit le filtre compte (une seule fois) √† partir des donn√©es locales
  const selEl = $('accountFilter');
  if(selEl && selEl.options && selEl.options.length <= 1){
    const emails = collectAccountEmails(all); // tri√©s
    for(const em of emails){
      const opt = document.createElement('option');
      opt.value = em;
      opt.textContent = aliasFromEmail(em);
      selEl.appendChild(opt);
    }
  }

  const accEmail = selEl ? (selEl.value||'').trim().toLowerCase() : '';

  if(!all.length){
    $('results').innerHTML = `<div class="item"><div class="muted err">Base produits vide. Va dans ‚öôÔ∏è R√©glages, puis ‚ÄúMettre √† jour base + mapping‚Äù.</div></div>`;
    return;
  }

  let filtered = all
    .filter(p=>{
      const tFold = foldText(p.title||'');
      const tFoldZh = foldText(p.title_zh||'');
      const asin=(p.asin||'').toString().toUpperCase();
      // Recherche sur titre / ASIN
      return !qFold || tFold.includes(qFold) || tFoldZh.includes(qFold) || asin.includes(q);
    })
    .filter(p=>{
      if(!accEmail) return true;
      const hist = Array.isArray(p?.history) ? p.history : [];
      return hist.some(h => (h.email||'').toString().trim().toLowerCase() === accEmail);
    })
    .sort((a,b)=>{
      // Tri par date de commande la plus r√©cente
      const tb = accEmail ? getLastOrderTimestampForEmail(b, accEmail) : getLastOrderTimestamp(b);
      const ta = accEmail ? getLastOrderTimestampForEmail(a, accEmail) : getLastOrderTimestamp(a);
      if(tb !== ta) return tb - ta; // plus r√©cent en premier
      return (b.orders_count||0) - (a.orders_count||0); // fallback
    })
    .slice(0,60);

  if(!filtered.length){
    $('results').innerHTML = `<div class="item"><div class="muted warn">Aucun r√©sultat.</div></div>`;
    return;
  }

  $('results').innerHTML = filtered.map(p=>`
    <div class="item">
      <div class="prod">${prodHTML(p)}</div>
      <div class="row" style="margin-top:8px">
        <button class="btnPrimary small" data-asin="${p.asin}">S√©lectionner</button>
        <span class="pill">cmd: ${p.orders_count||0}</span>
      </div>
    </div>
  `).join('');

  // bind select buttons
  $('results').querySelectorAll('button[data-asin]').forEach(btn=>{
    btn.onclick=async ()=>{
      const asin = btn.getAttribute('data-asin');
      selectedProduct = await idbGet('products', asin);
      await showConfirm();
    };
  });
}
async function showConfirm(){
  if(!selectedProduct) return;
  showOnly('confirmBox');
  $('confirmProd').innerHTML = prodHTML(selectedProduct);
  $('confirmLink').href = selectedProduct.product_url || '#';
  $('confirmAsin').textContent = 'ASIN: ' + selectedProduct.asin;
  $('confirmPrice').textContent = 'Prix: ' + (selectedProduct.price || '‚Äî');
  const badge = stateBadgesForFnsku((currentFnsku||'').toUpperCase().trim());
  $('confirmCaisses').textContent = 'üß∫ Stock global: ' + (badge && badge!=='‚Äî' ? badge.replace(/\s{2,}/g,' ¬∑ ') : '‚Äî');

  const hist = Array.isArray(selectedProduct.history) ? selectedProduct.history : [];
  $('histTable').innerHTML = hist.slice(0,80).map(h=>`
    <tr><td>${escapeHtml((h.order_date||'').toString())}</td><td>${escapeHtml((h.email||'').toString())}</td></tr>
  `).join('') || `<tr><td colspan="2" class="muted">Aucun historique en cache.</td></tr>`;

  $('linkStatus').textContent = '';
}

async function linkFnsku(){
  if(!selectedProduct) return;
  const fnsku = currentFnsku;
  const asin = selectedProduct.asin;

  if(!online()){
    $('linkStatus').textContent = '‚ùå Impossible de lier sans internet (global apr√®s synchro).';
    $('linkStatus').className = 'muted err';
    return;
  }
  if(!apiUrl || !secret){
    $('linkStatus').textContent = '‚ùå R√©glages API manquants.';
    $('linkStatus').className = 'muted err';
    return;
  }

  $('linkStatus').textContent = '‚è≥ Liaison en cours...';
  $('linkStatus').className = 'muted';

  // ‚úÖ Compat multi-versions backend : on essaie plusieurs "op" possibles.
  // Certains backends r√©pondent "unknown op" selon la version d√©ploy√©e.
  const candidates = [
    {op:'link_fnsku', fnsku, asin, device: deviceId, linked_at: new Date().toISOString()},
    {op:'save_mapping', fnsku, asin, device: deviceId, linked_at: new Date().toISOString()},
    {op:'upsert_mapping', fnsku, asin, device: deviceId, linked_at: new Date().toISOString()},
    {op:'link_fnsku_asin', fnsku, asin, device: deviceId, linked_at: new Date().toISOString()},
  ];

  let resp = null;
  let lastErr = '';
  for(const body of candidates){
    try{
      resp = await apiPost(body);
      if(resp && resp.ok) break;
      lastErr = (resp && resp.error) ? String(resp.error) : '';
      if(lastErr && !/unknown op/i.test(lastErr)) break; // vraie erreur => stop
    }catch(e){
      lastErr = String(e && (e.message||e) || '');
      // erreur r√©seau/HTTP => stop
      break;
    }
  }

  if(resp && resp.ok){
    // update local mapping cache
    await idbPut('mapping', {fnsku, asin, linked_at: new Date().toISOString(), device: deviceId});
    // update ASIN -> [FNSKU] map for UI
    addFnskuLinkLocal(fnsku, asin);

    $('linkStatus').textContent = '‚úÖ Lien cr√©√©';
    $('linkStatus').className = 'muted ok';

    // proceed to action box
    $('afterProd').innerHTML = prodHTML(selectedProduct, {fnsku: currentFnsku});
    proposeCaisse();
    showOnly('afterLinkBox');
    setStatus('Lien OK ‚Üí enregistre le rangement.', 'ok');
    await refreshPills();
    return;
  }

  // Gestion erreurs
  const e = (resp && resp.error) ? String(resp.error) : lastErr;
  if(e && e.startsWith('fnsku_already_linked:')){
    const already = e.split(':')[1] || '';
    $('linkStatus').textContent = '‚ö†Ô∏è D√©j√† li√© √† ' + already;
    $('linkStatus').className = 'muted warn';
    await pullAll();
  }else if(/unknown op/i.test(e||'')){
    $('linkStatus').textContent = '‚ùå Backend incompatible (op inconnue). Mets √† jour ton Apps Script ou dis-moi quelle version tu utilises.';
    $('linkStatus').className = 'muted err';
  }else{
    $('linkStatus').textContent = '‚ùå ' + (e || 'Erreur liaison');
    $('linkStatus').className = 'muted err';
  }
}

async function saveAction({fnsku, asin, caisse, action}){
  fnsku = normFnsku(fnsku);
  asin = normAsin(asin);
  caisse = (caisse||'').toString().trim().toUpperCase();
  action = (action||'').toString().trim().toUpperCase();

  if(!fnsku){ alert('FNSKU manquant'); return; }
  if(!asin || !/^[A-Z0-9]{10}$/.test(asin)){ alert('ASIN invalide'); return; }
  if(!caisse){ alert('Caisse obligatoire'); return; }

  // update last caisse global
  localStorage.setItem(LS.lastCaisse, caisse);
  // update caisses per ASIN (multi-caisses)
  applyQtyLocal(fnsku, asin, caisse, action);
  // refresh product detail instantly (badge in prodHTML)
  try{ if(selectedProduct){ $('knownProd').innerHTML = prodHTML(selectedProduct, {fnsku: currentFnsku}); } }catch(e){}
  // refresh product detail badge instantly
  if($('confirmCaisses')){
    const badge = stateBadgesForFnsku(fnsku);
    $('confirmCaisses').textContent = 'üß∫ Stock global: ' + (badge && badge!=='‚Äî' ? badge.replace(/\s{2,}/g,' ¬∑ ') : '‚Äî');
  }

  const saveKey = [fnsku, asin, caisse, action].join('|');
  const nowMs = Date.now();
  if(saveKey === lastSaveKey && (nowMs - lastSaveAt) < 1200){
    setStatus('‚ö†Ô∏è D√©j√† enregistr√© (anti-double-clic).', 'warn');
    return;
  }
  lastSaveKey = saveKey; lastSaveAt = nowMs;
  const id = makeStableActionId(fnsku, asin, caisse, action);
  const row = {
    id,
    ts: new Date().toISOString(),
    device: deviceId,
    fnsku,
    asin,
    caisse,
    action,
    synced: false
  };
  await idbPut('actions', row);
  await renderActions();
  await refreshPills();

  setStatus('Action enregistr√©e offline.', 'ok');

  // ‚úÖ Retour auto au scan
  resetToScan();

  // auto sync if online
  autoSync();
}

/* ===== Camera scan (Android Chrome) ===== */
let scanStream = null;
let scanTimer = null;
let lastScanValue = '';
let flashOn = false;

function buzz_(){
  try{ if(navigator.vibrate) navigator.vibrate(60); }catch(e){}
}
function beep_(){
  try{
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.connect(g); g.connect(ctx.destination);
    o.frequency.value = 880; g.gain.value = 0.05;
    o.start();
    setTimeout(()=>{ o.stop(); ctx.close(); }, 80);
  }catch(e){}
}

async function startScan_(){
  const overlay = $('scanOverlay');
  const video = $('scanVideo');
  const msg = $('scanMsg');

  if(!overlay || !video || !msg){
    setStatus('Scan cam√©ra: UI manquante.', 'err');
    return;
  }

  if(!('BarcodeDetector' in window)){
    overlay.style.display = 'block';
    msg.textContent = 'BarcodeDetector non support√© (Chrome Android r√©cent requis).';
    return;
  }

  // Stop any previous session
  stopScan_();

  overlay.style.display = 'block';
  msg.textContent = 'Ouverture cam√©ra‚Ä¶';

  scanStream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: 'environment' } },
    audio: false
  });

  video.srcObject = scanStream;
  await video.play();

  // Check flash support
  const track = scanStream.getVideoTracks()[0];
  if(track){
    const caps = track.getCapabilities ? track.getCapabilities() : {};
    if(caps.torch){
      $('btnFlash') && $('btnFlash').classList.remove('hidden');
      flashOn = false;
    } else {
      $('btnFlash') && $('btnFlash').classList.add('hidden');
    }
  }

  msg.textContent = 'Scanne le code‚Ä¶';

  const detector = new BarcodeDetector({
    formats: ['code_128','ean_13','ean_8','qr_code','data_matrix','itf']
  });

  lastScanValue = '';

  scanTimer = setInterval(async ()=>{
    try{
      const codes = await detector.detect(video);
      if(!codes || !codes.length) return;

      const raw = (codes[0].rawValue || '').trim();
      if(!raw) return;

      if(raw === lastScanValue) return;
      lastScanValue = raw;

      stopScan_();
      beep_(); buzz_();

      $('fnsku').value = raw;
      $('fnsku').dispatchEvent(new Event('input', {bubbles:true}));
      if(typeof lookupFnsku === 'function') await lookupFnsku();
    }catch(e){
      // ignore intermittent errors
    }
  }, 180);
}

function stopScan_(){
  if(scanTimer){ clearInterval(scanTimer); scanTimer = null; }
  if(scanStream){
    try{ scanStream.getTracks().forEach(t=>t.stop()); }catch(e){}
    scanStream = null;
  }
  const overlay = $('scanOverlay');
  if(overlay) overlay.style.display = 'none';
}

/* UI bindings */
$('btnLookup').onclick = lookupFnsku;
$('btnClear').onclick = ()=>{
  $('fnsku').value='';
  $('q').value='';
  $('results').innerHTML='';
  selectedProduct=null;
  currentFnsku='';
  showOnly(null);
  $('knownBox').classList.add('hidden');
  $('searchBox').classList.add('hidden');
  $('confirmBox').classList.add('hidden');
  $('afterLinkBox').classList.add('hidden');
  setStatus('Pr√™t.', '');
  $('fnsku').focus();
};
$('btnScanCam').onclick = ()=>{
  startScan_().catch(err=>{
    $('scanOverlay').style.display = 'block';
    $('scanMsg').textContent = 'Erreur cam√©ra: ' + (err.message || err);
  });
};
$('btnStopScan') && ($('btnStopScan').onclick = stopScan_);
$('btnFlash') && ($('btnFlash').onclick = () => {
  if(!scanStream) return;
  const track = scanStream.getVideoTracks()[0];
  if(!track) return;
  flashOn = !flashOn;
  try{
    track.applyConstraints({ advanced: [{ torch: flashOn }] });
  }catch(e){}
});

$('btnSearch').onclick = doSearch;
$('accountFilter').addEventListener('change', ()=>doSearch());
$('q').addEventListener('keydown', (e)=>{ if(e.key==='Enter') doSearch(); });

$('btnLink').onclick = linkFnsku;
$('btnChange').onclick = ()=>{
  showOnly('searchBox');
  $('linkStatus').textContent='';
};

$('btnSaveKnown').onclick = async ()=>{
  const fnsku = currentFnsku;
  const mapped = await idbGet('mapping', fnsku);
  const asin = mapped ? mapped.asin : '';
  await saveAction({fnsku, asin, caisse:$('caisseKnown').value, action:$('actionKnown').value});
};

$('btnSaveAfter').onclick = async ()=>{
  await saveAction({fnsku: currentFnsku, asin: selectedProduct.asin, caisse:$('caisseAfter').value, action:$('actionAfter').value});
};

$('btnSettings').onclick = ()=>{
    // init langue
    const lm = $('langMode');
    if(lm){ lm.value = getLang(); }
  $('settingsBox').classList.toggle('hidden'); };
// Langue (FR/‰∏≠Êñá)
$('langMode') && ($('langMode').onchange = ()=>{
  setLang($('langMode').value);
  // refresh UI
  if(selectedProduct) $('confirmProd').innerHTML = prodHTML(selectedProduct);
  if($('knownProd').innerHTML) { /* re-render happens next search */ }
  if(typeof renderLastActions==='function') renderLastActions();
});

$('btnCloseSettings').onclick = ()=>{ $('settingsBox').classList.add('hidden'); };

$('btnSaveSettings').onclick = async ()=>{
  apiUrl = ($('apiUrl').value||'').trim();
  secret = ($('secret').value||'').trim();
  localStorage.setItem(LS.apiUrl, apiUrl);
  localStorage.setItem(LS.secret, secret);
  $('settingsStatus').textContent = '‚úÖ Sauv√©. Fais ‚ÄúMettre √† jour base + mapping‚Äù.';
  await refreshPills();
};

$('btnResetCache').onclick = async ()=>{
  if(!confirm('Effacer base produits + mapping + actions locales ?')) return;
  await idbDelAll('products');
  await idbDelAll('mapping');
  await idbDelAll('actions');
  localStorage.removeItem(LS.stateMap);
  localStorage.removeItem(LS.lastPull);
  $('syncMsg').textContent='';
  setStatus('Cache effac√©.', 'warn');
  await renderActions();
  await refreshPills();
};

$('btnSyncNow').onclick = autoSync;
$('btnPullNow').onclick = pullAll;
$('btnRebuildState').onclick = async ()=>{
  try{
    $('syncMsg').textContent = '‚è≥ Rebuild stock serveur (depuis actions)...';
    const r = await apiGet({op:'rebuild_state'});
    if(!r.ok) throw new Error(r.error||'rebuild_state failed');

    const p = await apiGet({op:'pull_state'});
    if(!p.ok) throw new Error(p.error||'pull_state failed');

    const arr = p.state || [];
    const sm = {};
    for(const it of arr){
      const fn = (it.fnsku||'').toUpperCase().trim();
      const ca = (it.caisse||'').toUpperCase().trim();
      if(!fn || !ca) continue;
      if(!sm[fn]) sm[fn] = { asin: (it.asin||'').toUpperCase().trim(), caisses:{} };
      if(it.asin) sm[fn].asin = (it.asin||'').toUpperCase().trim();
      sm[fn].caisses[ca] = Number(it.qty||0)||0;
    }
    saveStateMap(sm);

    try{ if(selectedProduct){ $('knownProd').innerHTML = prodHTML(selectedProduct, {fnsku: currentFnsku}); } }catch(e){}
    try{ if($('confirmCaisses')){ const b = stateBadgesForFnsku((currentFnsku||'').toUpperCase().trim()); $('confirmCaisses').textContent = 'üß∫ Stock global: ' + (b && b!=='‚Äî' ? b.replace(/\s{2,}/g,' ¬∑ ') : '‚Äî'); } }catch(e){}

    refreshPills();
    $('syncMsg').textContent = `‚úÖ Rebuild OK ‚Äî rebuilt=${r.rebuilt||0} ‚Äî lignes STOCK_STATE=${arr.length}`;
  }catch(e){
    $('syncMsg').textContent = '‚ùå Rebuild: '+(e.message||e);
  }
};

/* Auto sync triggers */
window.addEventListener('online', ()=>{
  refreshPills();
  $('syncMsg').textContent = 'üåê R√©seau revenu ‚Üí sync auto...';
  autoSync();
});
window.addEventListener('offline', refreshPills);

// auto sync every 45s when online (lightweight)
setInterval(()=>{ if(online()) autoSync(); }, 45000);

/* Init */
(async function init(){
  db = await openDB();
  await refreshPills();
  await renderActions();

  // Autofocus for paste flow
  $('fnsku').focus();

  // If online and configured, pull base early
  if(online() && apiUrl && secret){
    await pullAll();
  }
})();
</script>
  <script>
(function () {

  function findFnskuInput() {
    // 1Ô∏è‚É£ priorit√© au placeholder FNSKU
    let el = [...document.querySelectorAll('input')]
      .find(i =>
        i.placeholder &&
        i.placeholder.toLowerCase().includes('fnsku')
      );

    if (el) return el;

    // 2Ô∏è‚É£ fallback : premier input texte visible
    el = [...document.querySelectorAll('input[type="text"]')]
      .find(i => i.offsetParent !== null);

    return el || null;
  }

  function focusAndSelect() {
    const input = findFnskuInput();
    if (!input) return;

    // petit d√©lai pour Android / PWA
    setTimeout(() => {
      input.focus();
      input.select();
    }, 80);
  }

  // üîÅ quand on revient depuis une autre app (Binary Eye)
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      focusAndSelect();
    }
  });

  // üîÅ au retour arri√®re Android
  window.addEventListener('pageshow', focusAndSelect);

  // üîÅ premier chargement
  window.addEventListener('load', focusAndSelect);

})();
</script>
</body>
</html>
